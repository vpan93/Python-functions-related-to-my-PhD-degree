## subspace clustering as it can be found here: Huang JZ, Xu J, Ng M, and Ye Y.  Weighting method for feature selection in k-means.  In:Computational Methods of feature selection, p. 209â€“226. Chapman and Hall/CRC, 2007 ###

def produce_U_sub(data,w,z,b):
    u=[]
    for i in range(data.shape[0]):
        interim_u=[]
        for l in range(z.shape[0]):
            interim_u.append(sum((w[j][l]**b)*(((data[i][j]-z[l][j]))**2) for j in range(0,data.shape[1])))
        u.append(interim_u)
    u=np.array(u)
    u=(u == u.min(axis=1)[:,None]).astype(int)
    return u

def produce_z(u,w,data):
    z_update=[]
    for l in range(u.shape[1]):
        z_update_interim=[]
        for j in range(len(w)):
            z_update_interim.append((sum(u[i][l]*data[i][j] for i in range(u.shape[0])))/(sum(u[i][l] for i in range(u.shape[0]))))
        z_update.append(z_update_interim)
    return np.array(z_update)

def D_l_j(j,u,z_updated,data):
    #for j in range(z_updated.shape[1]):
    d=0
    sigma=0.05
    for l in range(z_updated.shape[0]):
        for i in range(u.shape[0]):
            d=d+u[i][l]*((data[i][j]-z_updated[l][j])**2+sigma)
    return d

def produce_w_sub(u,z_updated,data,b):
    w_updated=[]
    if b>1 or b<=0:
        for l in range(z_updated.shape[0]):
            w_updated_interim=[]
            for j in range(z_updated.shape[1]):
                w_updated_interim.append(1/(sum((D_l_j(j,u,z_updated,data)/D_l_j(t,u,z_updated,data))**(1/(b-1)) for t in range(z_updated.shape[1]))))
            w_updated.append(w_updated_interim)
        return np.array(w_updated).transpose()

###  sub_wkmeans ###

def sub_wkmeans(data,k,b):
    z = data[np.random.choice(np.arange(len(data)), k, False)] ## initialise distinct centroids
    number_of_features=data.shape[1]
    number_of_records=data.shape[0]
    init_w=[]
    for i in range(k):
        temp_var=np.random.dirichlet(np.ones(number_of_features))
        temp_var=temp_var.tolist()
        init_w.append(temp_var) #initialise weights
    w=np.array(init_w)
    w=w.transpose()
    u=produce_U_sub(data,w,z,b)
    while True:
        z_updated=produce_z(u,w,data)
        w_updated=produce_w_sub(u,z_updated,data,b)
        u_updated=produce_U_sub(data,w_updated,z_updated,b)
        if np.array_equal(u, u_updated) == False:
            u=u_updated
        else:
            break
    return z_updated,w_updated,u_updated