####  wkmeans implemented from the following: Huang JZ, Xu J, Ng M, and Ye Y.  Weighting method for feature selection in k-means.  In:Computational Methods of feature selection, p. 209â€“226. Chapman and Hall/CRC, 2007 ####
def produce_U(data,w,z,b):
    u=[]
    for i in range(data.shape[0]):
        interim_u=[]
        for l in range(z.shape[0]):
            interim_u.append(sum((w[j]**b)*(((data[i][j]-z[l][j]))**2) for j in range(0,data.shape[1])))
        u.append(interim_u)
    u=np.array(u)
    u=(u == u.min(axis=1)[:,None]).astype(int)
    
    return u
def produce_z(u,w,data):
    z_update=[]
    for l in range(u.shape[1]):
        z_update_interim=[]
        for j in range(len(w)):
            z_update_interim.append((sum(u[i][l]*data[i][j] for i in range(u.shape[0])))/(sum(u[i][l] for i in range(u.shape[0]))))
        z_update.append(z_update_interim)
    return np.array(z_update)

def D_j(j,u,z_updated,data):
    #for j in range(z_updated.shape[1]):
    d=0
    for l in range(z_updated.shape[0]):
        for i in range(u.shape[0]):
            d=d+u[i][l]*((data[i][j]-z_updated[l][j])**2)
    return d

def produce_w(u,z_updated,data,b):
    h=z_updated.shape[1]
    w_updated=[]
    if b>1 or b<=0:
        for j in range(z_updated.shape[1]):
            if D_j(j,u,z_updated,data)==0:
                w_updated.append(0)
            else:
                w_updated.append(1/(sum((D_j(j,u,z_updated,data)/D_j(t,u,z_updated,data))**(1/(b-1)) for t in range(z_updated.shape[1]))))
        return np.array(w_updated)
        
###  wkmeans ###
def wkmeans(data,k,b):
    z = data[np.random.choice(np.arange(len(data)), k, False)] ## initialise distinct centroids
    number_of_features=data.shape[1]
    number_of_records=data.shape[0]
    w=np.random.dirichlet(np.ones(number_of_features))*1 #initialise weights
    u=produce_U(data,w,z,b)
    while True:
        z_updated=produce_z(u,w,data)
        w_updated=produce_w(u,z_updated,data,b)
        u_updated=produce_U(data,w_updated,z_updated,b)
        if np.array_equal(u, u_updated) == False:
            u=u_updated
        else:
            break
    return z_updated,w_updated,u_updated